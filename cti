#!/bin/bash
#
# General config - set some sane defaults
#
# The editor that should be used to edit files
# If unset, the content of the EDITOR variable is used.
# If that is also unset, vi is used
CTI_EDITOR=vim
#
# The tool to show conflicts. 
# If unset, diff is used. If that is not available,
# differences are not shown.
CTI_DIFFTOOL=diff
CTI_DIFFOPTS="-s -N -u"
#
# The tool to resolve conflicts.
# If unset, vimdiff is used. If that is not available,
# merging is not suggested
CTI_MERGETOOL=vimdiff
CTI_MERGEOPTS=""
#
# Target directory. 
BACKUP_DIR=/srv/config/
#
# Delay in seconds between a printed message and opening the
# file in an editor
MSG_DELAY=1.0
#
# Read global config if present
[ -f /etc/ctirc ] && source /etc/ctirc
#
# Read user config if present
[ -f $HOME/.ctirc ] && source $HOME/.ctirc
#
# Include other files
BASEDIR=$(dirname $0)
source $BASEDIR/inc_msg.sh
source $BASEDIR/inc_user_input.sh
#
# Check toolchain
[ -x /usr/bin/${CTI_DIFFTOOL:=diff} ] || CTI_DIFFTOOL=no_diff
#
[ -x /usr/bin/${CTI_MERGETOOL:=vimdiff} ] || CTI_MERGETOOL=no_merge
#

function print_usage(){
cat << EOF
Usage: $(basename $0) [<OPTIONS>] <ACTION> <FILE> [<FILE> ... ]

$(basename $0) allows you to organize the backup of your config files.
It maintains a copy of the file hierarchy of your system with only those
files that are relevant. 

ACTIONs:
    add
        Start tracking the specified files

    edit
        Edit the specifed files and start tracking them

    check
        Only check the current status of the specified files

    sync
        Same as check, but proposes actions for diverged files

    recover
        Recursively sync all files in the backup. Only action that does
        not expect FILE argument(s)

    remove
        Remove specified files from the file system and the backup

    restore
        Restore specified files from the backup

    untrack
        Remove specified files from the backup

Options:
    -d, --debug
        Enable debug mode

    -h, --help
        Prints this help text

Configuration
    To modify the behavior of $(basename $0) see the config in the head of this
    script. The settings can be overridden by settings specified in /etc/ctirc.
    This in turn can be overridden in a user config file in \$HOME/.ctirc.
EOF
}

function no_diff () {
    print_error "No difftool available"
}

function no_merge () {
    print_error "No mergetool available"
    exit -1;
}

function checksum (){
    local file=$1
    md5sum -- $file | cut -d' ' -f 1
}

function fullpath () {
    local file=$1
    if [ -d "$file" ];then
        cd -- $file
        pwd
    else
        local filename=$(basename -- "$file")
        local dir=${file%/*}
        [ -d "$dir" ] && cd "$dir"
        local path="$PWD"
        echo ${path}/${filename}
    fi
}

function backup_file () {
    local file=$1
    [ -d "$file" ] && return
    if [ ! -f "$file" ]; then
        print_error "Cannot backup non-existent file $file"
        return
    fi
    local path=$(fullpath $file)
    local temp_dir=$(mktemp -d)
    rsync -ptgolR -T $temp_dir -- $path $BACKUP_DIR/ && \
    print_ok "File $file synced with backup successfully!"
    rm -rf $temp_dir
}

function restore_file () {
    local file=$1
    [ -d "$file" ] && return
    local path=$(fullpath $file)
    local temp_dir=$(mktemp -d)
    rsync -ptgol -T $temp_dir -- $BACKUP_DIR/$path $path
    rm -rf -- $temp_dir
}

function check_backup_dir () {
    [ -z "$BACKUP_DIR" ] && abort "The BACKUP_DIR variable is not set!"
    [ "x$BACKUP_DIR" = "x/" ] && abort "The BACKUP_DIR variable is not valid!"
}

function untrack_file () {
    check_backup_dir
    local file=$1
    rm -i -- ${BACKUP_DIR}$(fullpath ${file})
}

function remove_file () {
    local file=$1
    untrack_file $file
    rm -i -- ${file}
}


function handle_diverged_file () {
    local file_abs_path=$1
    local missing=${2:="n"}
    if [ "x$missing" == "xy" ];then
        echo "File is present in the backup but not locally!"
    else
        echo "Changes:"
        ${CTI_DIFFTOOL} ${CTI_DIFFOPTS} $BACKUP_DIR/$file_abs_path $file_abs_path  
    fi
    echo ""
    echo "What do you want to do?"
    local selection=0
    if [ "x$missing" == "xy" ];then
        mchoice selection "Restore backup" "Delete in backup" "Ignore" "Abort"
    else
        mchoice selection "Open mergetool" "Restore backup" "Overwrite backup" "Ignore" "Abort"
    fi
    case "$selection" in 
        'Open mergetool')
            ${CTI_MERGETOOL} ${CTI_MERGEOPTS} $file_abs_path $BACKUP_DIR/$file_abs_path
            ;;
        'Restore backup')
            restore_file $file_abs_path
            ;;
        "Delete in backup")
            untrack_file $file_abs_path
            ;;
        'Overwrite backup')
            backup_file $file_abs_path
            ;;
        'Ignore')
            ;;
        'Abort')
            exit 0
            ;;
        *)
            abort "Invalid selection $selection"
            ;;
    esac
}

function check_file () {
    local file=$1
    local delay=${2:=0}
    local sync=${3:-y}
    local path=$(fullpath $file)
    
    if [ ! -e $path ] && [ ! -e ${BACKUP_DIR}/$path ]; then
        echo -e "[\e[1;33m??\e[m] NEW           $path"
        sleep $delay
        return
    elif [ -e $path ] && [ ! -e ${BACKUP_DIR}/$path ]; then
        echo -e "[\e[1;33m??\e[m] UNTRACKED     $path"
        sleep $delay
        return
    elif [ ! -e $path ] && [ -e ${BACKUP_DIR}/$path ]; then
        echo -e "[\e[1;33m??\e[m] MISSING       $path"
        [ "x$sync" == "xy" ] && handle_diverged_file $path  "y"
        return
    elif [ -e $path ] && [ -e ${BACKUP_DIR}/$path ]; then
        [ -d $path ] && return
        [ -d ${BACKUP_DIR}/$path ] && return

        local stored_checksum=$(checksum ${BACKUP_DIR}/${path}) 
        local checksum_before=$(checksum ${path})
        if [ "$stored_checksum" != "$checksum_before" ];then
            echo -e "[\e[1;31m!!\e[m] OUT OF SYNC   $path"
            [ "x$sync" == "xy" ] && handle_diverged_file $path "n"
        else
            echo -e "[\033[00;32mOK\e[m] IN SYNC       $path"
            sleep $delay
        fi
    fi
}

function edit_file () {
    local file=$1
    check_file $file $MSG_DELAY "y"
    checksum_before=$(checksum $file)
    ${CTI_EDITOR:-${EDITOR:-vi}} $file
    checksum_after=$(checksum $file)
    if [ "$checksum_before" != "$checksum_after" ]; then
        backup_file $file
    else
        echo "Not syncing file because no changes where made!"
    fi
}

function recover_dir () {
    local dir=$1
    [ -d "$dir" ] || abort "Unexpected error: $dir is not a directory!"
    for file in ${dir}/{*,.*}; do
        if [ "${dir}/." == "$file" ] || [ "${dir}/.." == "$file" ] || [ "${dir}/*" == "$file" ];then
            continue
        fi
        if [ -d "$file" ];then
            recover_dir "$file"
        else
            local stripped_file=$(echo $file | sed -e s#$BACKUP_DIR##)
            check_file "$stripped_file" 0 "n"
        fi
    done
}

function recover () {
    if [ $UID -ne 0 ] ;then
        abort "Action recover should be run as root!"
    fi
    check_backup_dir
    recover_dir "$BACKUP_DIR"
}

########### READ COMMAND LINE ARGUMENTS ############

if [ "x$1" == "x-h" ] || [ "x$1" == "x--help" ];then
    print_usage
    exit 0
fi
ACTION="none"
FILES=""
NO_OPTS="n"
while [ $# -gt 0 ];do
    case $1 in 
        '--')
            NO_OPTS="y"
            ;;
        'add'|'check'|'edit'|'recover'|'remove'|'restore'|'sync'|'untrack')
            if [ "x$ACTION" == "xnone" ];then
                ACTION="$1"
            else 
                FILES+="$1 "
            fi
            ;;
        '-d'|'--debug')
            if [ "x$NO_OPTS" == "xy" ];then
                FILES+="$1 "
            else
                set -xe
            fi
            ;;
        '-h'|'--help')
            if [ "x$NO_OPTS" == "xy" ];then
                FILES+="$1 "
            else
                print_usage
                exit 0
            fi
            ;;
        *)
            FILES+="$1 "
            ;;
    esac
    shift
done

############# CHECK COMMAND LINE ARGS ################

[ "x$ACTION" == "xnone" ] && abort "No valid action provided!"

# Recover is the only action that does not expect further arguments
if [ "x$ACTION" == "xrecover" ];then
    recover
    exit 0
fi

if [ -z "$FILES" ]; then
    abort "Arguments missing!"
fi

########## CHECK BACKUP_DIR AND PERMISSIONS ##########

if [ ! -d "${BACKUP_DIR}" ]; then
    mkdir -p "${BACKUP_DIR}" || \
    print_error "The backup directory ${BACKUP_DIR} does not yet exist. Backup at least one file as root to fix this"
    exit -1
fi

if [ $UID -ne 0 ] && [ ! -w "${BACKUP_DIR}/${HOME}" ];then
    print_error "User $USER does not have a writable home directory in the backup folder"
    echo "Backup at least one file in this user's home dir as root to fix this"
    exit -1
fi

############### MAIN SWITCH ##########################

for FILE in $FILES; do
    case $ACTION in
        'add')
            if [ -f $BACKUP_DIR/$(fullpath $FILE) ]; then
                echo "File $FILE is already being tracked!"
            else
                backup_file $FILE
            fi
            ;;
        'check')
            check_file $FILE 0 "n"
            ;;
        'edit')
            edit_file $FILE
            ;;
        'remove')
            remove_file $FILE
            ;;
        'restore')
            restore_file $FILE
            ;;
        'sync')
            check_file $FILE 0 "y"
            ;;
        'untrack')
            untrack_file $FILE
            ;;
        *)
            abort "Unrecognized action $ACTION"
            ;;
    esac
done
