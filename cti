#!/bin/bash
#
# General config - set some sane defaults
#
# The editor that should be used to edit files
# If unset, the content of the EDITOR variable is used.
# If that is also unset, vi is used
CTI_EDITOR=vim
#
# The tool to show conflicts. 
# If unset, diff is used. If that is not available,
# differences are not shown.
CTI_DIFFTOOL=diff
CTI_DIFFOPTS="-s -N -u"
#
# The tool to resolve conflicts.
# If unset, vimdiff is used. If that is not available,
# merging is not suggested
CTI_MERGETOOL=vimdiff
CTI_MERGEOPTS=""
#
# Target directory. 
BACKUP_DIR=/var/cti/data/
#
# Delay in seconds between a printed message and opening the
# file in an editor
MSG_DELAY=1.0
#
# Read global config if present
[ -f /etc/ctirc ] && source /etc/ctirc
#
# Read user config if present
[ -f $HOME/.ctirc ] && source $HOME/.ctirc
#
# Include other files
BASEDIR=$(dirname $0)
source $BASEDIR/inc_msg.sh
source $BASEDIR/inc_user_input.sh
#
# Check toolchain
[ -x /usr/bin/${CTI_DIFFTOOL:=diff} ] || CTI_DIFFTOOL=no_diff
#
[ -x /usr/bin/${CTI_MERGETOOL:=vimdiff} ] || CTI_MERGETOOL=no_merge
#

function print_usage(){
cat << EOF
Usage: $(basename $0) [<OPTIONS>] <ACTION> <FILE> [<FILE> ... ]

$(basename $0) allows you to organize the backup of your config files.
It maintains a copy of the file hierarchy of your system with only those
files that are relevant. 

ACTIONs:
    add
        Start tracking the specified files

    check
        Only check the current status of the specified files

    check-all
        Recursively check all files in the backup. Does not expect 
        FILE argument(s)

    edit
        Edit the specifed files and start tracking them

    remove
        Remove specified files from the file system and the backup

    restore
        Restore specified files from the backup

    sync
        Same as check, but proposes actions for diverged files

    sync-all
        Recursively sync all files in the backup. Does not expect 
        FILE argument(s)

    untrack
        Remove specified files from the backup

Options:
    -a, --abort-on-conflict
        Always abort in case of conflict in conjunction with sync action.
        Conflicts with all other "*-on-conflict" flags.

    -b, --backup-on-conflict
        Always overwrite the backup with the current state of the file in
        case of conflict in conjunction with sync action.
        Conflicts with all other "*-on-conflict" flags.
    
    -d, --debug
        Enable debug mode.

    -h, --help
        Prints this help text.

    -i, --ignore-on-conflict
        Always ignore conflicts in conjunction with sync action.
        Conflicts with all other "*-on-conflict" flags.

    -r, --restore-on-conflict
        Always restore the backup and overwrite the current state in case
        of conflict in conjunction with sync action.
        Conflicts with all other "*-on-conflict" flags.

    -s, --suppress-synced
        Suppresses output of files in sync in conjunction with actions
        check and sync.

    -u, --untrack-on-conflict
        Always delete backup file (i.e. untrack file) in case of conflict
        in conjunction with sync action.
        Conflicts with all other "*-on-conflict" flags.

Configuration
    To modify the behavior of $(basename $0) see the config in the head of this
    script. The settings can be overridden by settings specified in /etc/ctirc.
    This in turn can be overridden in a user config file in \$HOME/.ctirc.
EOF
}

function no_diff () {
    print_error "No difftool available"
}

function no_merge () {
    print_error "No mergetool available"
    exit -1;
}

function checksum (){
    local file=$1
    md5sum -- $file | cut -d' ' -f 1
}

function fullpath () {
    local file=$1
    if [ -d "$file" ];then
        cd -- $file
        pwd
    else
        local filename=$(basename -- "$file")
        local dir=${file%/*}
        [ -d "$dir" ] && cd "$dir"
        local path="$PWD"
        echo ${path}/${filename}
    fi
}

function backup_file () {
    local file=$1
    [ -d "$file" ] && return
    if [ ! -f "$file" ]; then
        print_error "Cannot backup non-existent file $file"
        return
    fi
    local path=$(fullpath $file)
    local temp_dir=$(mktemp -d)
    rsync -ptgolR -T $temp_dir -- $path $BACKUP_DIR/ && \
    print_ok "File $file synced with backup successfully!"
    rm -rf $temp_dir
}

function restore_file () {
    local file=$1
    [ -d "$file" ] && return
    local path=$(fullpath $file)
    local temp_dir=$(mktemp -d)
    rsync -ptgol -T $temp_dir -- $BACKUP_DIR/$path $path
    rm -rf -- $temp_dir
}

function check_backup_dir () {
    [ -z "$BACKUP_DIR" ] && abort "The BACKUP_DIR variable is not set!"
    [ "x$BACKUP_DIR" = "x/" ] && abort "The BACKUP_DIR variable is not valid!"
}

function untrack_file () {
    check_backup_dir
    local file=$1
    rm -i -- ${BACKUP_DIR}$(fullpath ${file})
}

function remove_file () {
    local file=$1
    untrack_file $file
    rm -i -- ${file}
}

function handle_diverged_file () {
    local file_abs_path=$1
    local missing=${2:="n"}
    if [ "x$missing" == "xy" ];then
        echo "File is present in the backup but not locally!"
    else
        echo "Changes:"
        ${CTI_DIFFTOOL} ${CTI_DIFFOPTS} $BACKUP_DIR/$file_abs_path $file_abs_path  
    fi
    echo ""
    local selection=0
    case $CONFLICT_RESOLUTION in 
        'abort')
            selection="Abort"
            ;;
        'backup')
            selection="Overwrite backup"
            ;;
        'ignore')
            selection="Ignore"
            ;;
        'restore')
            selection="Restore backup"
            ;;
        'untrack')
            selection="Untrack file"
            ;;
        *)
            echo "What do you want to do?"
            if [ "x$missing" == "xy" ];then
                mchoice selection "Restore backup" "Delete in backup" "Ignore" "Abort"
            else
                mchoice selection "Open mergetool" "Restore backup" "Overwrite backup" "Untrack file" "Ignore" "Abort"
            fi
            ;;
    esac

    case "$selection" in 
        'Open mergetool')
            ${CTI_MERGETOOL} ${CTI_MERGEOPTS} $file_abs_path $BACKUP_DIR/$file_abs_path
            ;;
        'Restore backup')
            restore_file $file_abs_path
            ;;
        'Delete in backup'|'Untrack file')
            untrack_file $file_abs_path
            ;;
        'Overwrite backup')
            backup_file $file_abs_path
            ;;
        'Ignore')
            ;;
        'Abort')
            exit 0
            ;;
        *)
            abort "Invalid selection $selection"
            ;;
    esac
}

function check_file () {
    local file=$1
    local delay=${2:=0}
    local sync=${3:-y}
    local full_path=$(fullpath $file)
    local path=$(echo $full_path | \
        sed -e s#^$BACKUP_DIR##  | \
        sed -e 's#^\([^/]\)#/\1#g') # prepend slash if needed
    
    if [ ! -e $path ] && [ ! -e ${BACKUP_DIR}/$path ]; then
        echo -e "[\e[1;33m??\e[m] NEW           $path"
        sleep $delay
        return
    elif [ -e $path ] && [ ! -e ${BACKUP_DIR}/$path ]; then
        echo -e "[\e[1;33m??\e[m] UNTRACKED     $path"
        sleep $delay
        return
    elif [ ! -e $path ] && [ -e ${BACKUP_DIR}/$path ]; then
        echo -e "[\e[1;31m!!\e[m] MISSING       $path"
        [ "x$sync" == "xy" ] && handle_diverged_file $path  "y"
        return
    elif [ -e $path ] && [ -e ${BACKUP_DIR}/$path ]; then
        [ -d $path ] && return
        [ -d ${BACKUP_DIR}/$path ] && return

        local stored_checksum=$(checksum ${BACKUP_DIR}/${path}) 
        local checksum_before=$(checksum ${path})
        if [ "$stored_checksum" != "$checksum_before" ];then
            echo -e "[\e[1;31m!!\e[m] OUT OF SYNC   $path"
            [ "x$sync" == "xy" ] && handle_diverged_file $path "n"
        elif [ "x$SUPPRESS_SYNCED" != "xy" ];then
            echo -e "[\033[00;32mOK\e[m] IN SYNC       $path"
            sleep $delay
        fi
    fi
}

function edit_file () {
    local file=$1
    check_file $file $MSG_DELAY "y"
    checksum_before=$(checksum $file)
    ${CTI_EDITOR:-${EDITOR:-vi}} $file
    checksum_after=$(checksum $file)
    if [ "$checksum_before" != "$checksum_after" ]; then
        backup_file $file
    else
        echo "Not syncing file because no changes where made!"
    fi
}

function export_globals () {
    export CTI_EDITOR
    export CTI_DIFFTOOL
    export CTI_DIFFOPTS
    export CTI_MERGETOOL
    export CTI_MERGEOPTS
    export BACKUP_DIR
    export MSG_DELAY
    export -f mchoice
    export -f abort
    export -f print_ok
    export -f print_warning
    export -f print_error
    export -f print_usage
    export -f no_diff
    export -f no_merge
    export -f checksum
    export -f fullpath
    export -f backup_file
    export -f restore_file
    export -f check_backup_dir
    export -f untrack_file
    export -f remove_file
    export -f handle_diverged_file
    export -f check_file
    export -f edit_file
    export -f check_all
}

function check_all () {
    local sync=${1:="n"}
    check_backup_dir
    export_globals
    find $BACKUP_DIR -type f -readable -exec bash -c "check_file {} 0 $sync" \;  
    if [ $UID -ne 0 ];then
        local unreadable=$(find $BACKUP_DIR ! -readable | wc -l)
        [ $unreadable -gt 0 ] && print_warning "Some files or folders could not be read. You may want to re-run cti with higher priviliges."
    fi
}

function set_conflict_resolution () {
    local resolution=$1
    if [ "x$CONFLICT_RESOLUTION" != "xmanual" ];then
        print_error "Invalid combination of command line flags! Only one automatic conflict resolution strategy can be set!"
        echo ""
        print_usage
        exit -1
    fi
    CONFLICT_RESOLUTION="$resolution"
}

########### READ COMMAND LINE ARGUMENTS ############

if [ "x$1" == "x-h" ] || [ "x$1" == "x--help" ];then
    print_usage
    exit 0
fi
export ACTION="none"
export FILES=""
export NO_OPTS="n"
export SUPPRESS_SYNCED="n"
export CONFLICT_RESOLUTION="manual"
while [ $# -gt 0 ];do
    case $1 in 
        '--')
            NO_OPTS="y"
            ;;
        'add'|'check'|'check-all'|'edit'|'remove'|'restore'|'sync'|'sync-all'|'untrack')
            if [ "x$ACTION" == "xnone" ];then
                ACTION="$1"
            else 
                FILES+="$1 "
            fi
            ;;
        '-a'|'--abort-on-conflict')
            set_conflict_resolution "abort"
            ;;
        '-b'|'--backup-on-conflict')
            set_conflict_resolution "backup"
            ;;
        '-d'|'--debug')
            if [ "x$NO_OPTS" == "xy" ];then
                FILES+="$1 "
            else
                set -xe
            fi
            ;;
        '-h'|'--help')
            if [ "x$NO_OPTS" == "xy" ];then
                FILES+="$1 "
            else
                print_usage
                exit 0
            fi
            ;;
        '-i'|'--ignore-on-conflict')
            set_conflict_resolution "ignore"
            ;;
        '-r'|'--restore-on-conflict')
            set_conflict_resolution "restore"
            ;;
        '-s'|'--suppress-synced')
            SUPPRESS_SYNCED="y"
            ;;
        '-u'|'--untrack-on-conflict')
            set_conflict_resolution "untrack"
            ;;
        *)
            FILES+="$1 "
            ;;
    esac
    shift
done

########## CHECK BACKUP_DIR AND PERMISSIONS ##########

if [ ! -d "${BACKUP_DIR}" ]; then
    mkdir -p "${BACKUP_DIR}" || \
    abort "The backup directory ${BACKUP_DIR} does not yet exist. Backup at least one file as root to fix this"
fi

if [ $UID -ne 0 ] && [ ! -w "${BACKUP_DIR}/${HOME}" ];then
    print_error "User $USER does not have a writable home directory in the backup folder"
    abort "Backup at least one file in this user's home dir as root to fix this"
fi

# Recover is the only action that does not expect further arguments
if [ "x$ACTION" == "xcheck-all" ];then
    check_all "n"
    exit 0
elif [ "x$ACTION" == "xsync-all" ];then
    check_all "y"
    exit 0
fi

if [ -z "$FILES" ]; then
    abort "Arguments missing!"
fi

############# CHECK COMMAND LINE ARGS ################

[ "x$ACTION" == "xnone" ] && abort "No valid action provided!"


############### MAIN SWITCH ##########################

for FILE in $FILES; do
    case $ACTION in
        'add')
            if [ -f $BACKUP_DIR/$(fullpath $FILE) ]; then
                echo "File $FILE is already being tracked!"
            else
                backup_file $FILE
            fi
            ;;
        'check')
            check_file $FILE 0 "n"
            ;;
        'edit')
            edit_file $FILE
            ;;
        'remove')
            remove_file $FILE
            ;;
        'restore')
            restore_file $FILE
            ;;
        'sync')
            check_file $FILE 0 "y"
            ;;
        'untrack')
            untrack_file $FILE
            ;;
        *)
            abort "Unrecognized action $ACTION"
            ;;
    esac
done
